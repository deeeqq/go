# Указатели
Указатели представляют собой объекты, значением которых служат адреса других объектов (например, переменных).

Указатель определяется как обычная переменная, только перед типом данных ставится символ звездочки `*`. Например, определение указателя на объект типа int:

``` go
var p *int
```
Этому указателю можно присвоить адрес переменной типа int. Для получения адреса применяется операция &, после которой указывается имя переменной (&x).

``` go
package main

import "fmt"

func main() {

    var x int = 4       // определяем переменную
    var p *int          // определяем указатель 
    p = &x              // указатель получает адрес переменной
    fmt.Println(p)      // значение самого указателя - адрес переменной x
}
```
Здесь указатель p хранит адрес переменной x. Что важно, переменная x имеет тип int, и указатель p указывает именно на объект типа int. То есть должно быть соответствие по типу. И если мы попробуем вывести адрес переменной на консоль, то увидим, что он представляет шестнадцатеричное значение:

`0xc0420120a0`

В каждом отдельном случае адрес может отличаться, но к примеру, в моем случае машинный адрес переменной x - 0xc0420120a0. То есть в памяти компьютера есть адрес 0xc0420120a0, по которому располагается переменная x.

По адресу, который хранит указатель, мы получить значение переменной x. Для этого применяется операция * или операция разыменования. Результатом этой операции является значение переменной, на которую указывает указатель. Применим данную операцию и получим значение переменной x:

``` go
package main

import "fmt"

func main() {

    var x int = 4
    var p *int  = &x                // указатель получает адрес переменной
    fmt.Println("Address:", p)      // значение указателя - адрес переменной x
    fmt.Println("Value:", *p)       // значение переменной x
}
```
Консольный вывод:
```
Address: 0xc0420c058
Value: 4
```
И также используя указатель, мы можем менять значение по адресу, который хранится в указателе:

``` go
var x int = 4
var p *int = &x
*p = 25
fmt.Println(x)      // 25
```
Для определения указателей можно использовать также сокращенную форму:

``` go
f := 2.3
pf := &f

fmt.Println("Address:", pf)
fmt.Println("Value:", *pf)
```
## Пустой указатель
Если указателю не присвоен адрес какого-либо объекта, то такой указатель по умолчанию имеет значение nil (по сути отстутствие значения). Если мы попробуем получить значение по такому пустому указателю, то мы столкнемся с ошибкой:

``` go
var pf *float64
fmt.Println("Value:", *pf)  // ! ошибка, указатель не указывает на какой-либо объект
```
Поэтому при работе с указателями иногда бывает целесообразано проверять на значение nil:

``` go
var pf *float64
if pf != nil{
fmt.Println("Value:", *pf)
}
```
## Функция new
Переменная представляет именованный объект в памяти. Язык Go также позволяет создавать безымянные объекты - они также размещаются в памяти, но не имеют имени как переменные. Для этого применяется функция new(type). В эту функцию передается тип, объект которого надо создать. Функция возвращает указатель на созданный объект:

``` go
package main

import "fmt"

func main() {

    p := new(int) 
    fmt.Println("Value:", *p)       // Value: 0 - значение по умолчанию
    *p = 8                          // изменяем значение
    fmt.Println("Value:", *p)       // Value: 8
}
```
В данном случае указатель p будет иметь тип *int, поскольку он указывает на объект типа int. Создаваемый объект имеет значение по умолчанию (для типа int это число 0).

Объект, созданный с помощью функции new, ничем не отличается от обычной переменной. Единственное что, чтобы обратиться к этому объекту - получить или изменить его адрес, необходимо использовать указатель.

# SOLID

Это наиболее известный принцип разработки ПО. Solid — это аббревиатура от:

## S) Single-responsibility principle /Принцип единственной ответственности

Его важность невозможно переоценить. Каждый объект, класс и метод должны отвечать только за что-то одно. Если ваш объект/класс/метод делает слишком много, вы получите спагетти-код. Вот пример:
``` go
const saveTodo = async () => {
try {
response = await saveTodoApi();
showSuccessPop('Success');
window.location.href = '/successPage';
} catch (error) {
showErrorPopup(`Error: ${error} `);
}
}
```
Этот метод кажется безобидным, но на самом деле он делает слишком много:

Сохраняет объект
Обрабатывает уведомление в UI
Выполняет навигацию

Еще один побочный эффект такого кода – проблемы с тестированием. Запутанный функционал тестировать сложно.

## O) Open–closed principle / Принцип открытости-закрытости

Программные объекты должны быть открыты для расширения, но закрыты для модификации. Речь о том, что нельзя переопределять методы или классы, просто добавляя дополнительные функции по мере необходимости.

Хороший способ решения этой проблемы – использование наследования. В JavaScript эта проблема решается с помощью композиции.

Простое правило: если вы изменяете сущность, чтобы сделать ее расширяемой, вы впервые нарушили этот принцип.

## L) Liskov substitution principle / Принцип подстановки Лисков

Этот принцип гласит, что объекты старших классов должны быть заменимы объектами подклассов, и приложение при такой замене должно работать так, как ожидается.

## I) Interface segregation principle / Принцип разделения интерфейсов

Этот принцип был сформулирован Робертом Мартином, когда он консультировал Xerox, и он очевиден.

Объекты не должны зависеть от интерфейсов, которые они не используют


ПО должно разделяться на независимые части. Побочные эффекты необходимо сводить к минимуму, чтобы обеспечивать независимость.

Убедитесь, что вы не заставляете объекты реализовывать методы, которые им никогда не понадобятся. Вот пример:
``` go
interface Animal {
eat: () => void;
walk: () => void;
fly: () => void;
swim: () => void;
}
```
Не все животные могут fly, walk или swim, поэтому эти методы не должны быть частью интерфейса или должны быть необязательными.

## D) Dependency inversion principle / Принцип инверсии зависимостей

Этот принцип невозможно переоценить. Мы должны полагаться на абстракции, а не на конкретные реализации. Компоненты ПО должны иметь низкую связность и высокую согласованность.

Заботиться нужно не о том, как что-то устроено, а о том, как оно работает. Простой пример – использование дат в JavaScript. Вы можете написать для них свой слой абстракции. Тогда если у вас сменится источник получения дат, вам нужно будет внести изменения в одном месте, а не в тысяче.

Иногда добавление этого уровня абстракции требует усилий, но в конечном итоге они окупаются.

В качестве примера взгляните на date-io, в этой библиотеке создан тот уровень абстракции, который позволяет вам использовать её с разными источниками дат.

# KISS
Keep It Simple, Stupid / Будь проще

Этот принцип был разработан ВМС США в 1960 году. Этот принцип гласит, что простые системы будут работать лучше и надежнее.

У этого принципа много общего с переизобретением колеса, которым занимались в 1970-х. Тогда он звучал как деловая и рекламная метафора.

Применительно к разработке ПО он значит следующее – не придумывайте к задаче более сложного решения, чем ей требуется.

Иногда самое разумное решение оказывается и самым простым. Написание производительного, эффективного и простого кода – это прекрасно.

Одна из самых распространенных ошибок нашего времени – использование новых инструментов исключительно из-за того, что они блестят. Разработчиков следует мотивировать использовать новейшие технологии не потому, что они новые, а потому что они подходят для работы.

# DRY
Don’t Repeat Yourself / Не повторяйтесь

Эта концепция была впервые сформулирована в книге Энди Ханта и Дэйва Томаса «Программист-прагматик: путь от подмастерья к мастеру».

Идея вращается вокруг единого источника правды (single source of truth — SSOT). Что это вообще такое?

В проектировании и теории информационных систем единый источник истины (SSOT) – это практика структурирования информационных моделей и схемы данных, которая подразумевает, что все фрагменты данных обрабатываются (или редактируются) только в одном месте… SSOT предоставляют достоверные, актуальные и пригодные к использованию данные.


# Пакеты и модули
## Пакеты и их импорт

Использование SSOT позволит создать более прочную и понятную кодовую базу.

Дублирование кода – пустая трата времени и ресурсов. Вам придется поддерживать одну и ту же логику и тестировать код сразу в двух местах, причем если вы измените код в одном месте, его нужно будет изменить и в другом.

В большинстве случаев дублирование кода происходит из-за незнания системы. Прежде чем что-либо писать, проявите прагматизм: осмотритесь. Возможно, эта функция где-то реализована. Возможно, эта бизнес-логика существует в другом месте. Повторное использование кода – всегда разумное решение.


Весь код в языке Go организуется в пакеты. Пакеты представляют удобную организацию разделения кода на отдельные части или модули. Модульность позволяет определять один раз пакет с нужной функциональностью и потом использовать его многкратно в различных программах.

Код пакета располагается в одном или нескольких файлах с расширением go. Для определения пакета применяется ключевое слово package. Например:

``` go
package main
import "fmt"

func main() {

    fmt.Println("Hello Go")
}
```
В данном случае пакет называется main. Определение пакета должно идти в начале файла.

Есть два типа пакетов: исполняемые (executable) и библиотеки (reusable). Для создания исполняемых файлов пакет должен иметь имя main. Все остальные пакеты не являются исполняемыми. При этом пакет main должен содержать функцию main, которая является входной точкой в приложение.

## Импорт пакетов
Если уже есть готовые пакеты с нужной нам функциональностью, которую мы хотим использовать, то для их использования мы можем их импортировать в программу с помощью оператора import. Например, в примере выше задействуется функциональность вывода сообщения на консоль с помощью функции Println, которая определена в пакете fmt. Соответственно чтобы использовать эту функцию, необходимо импортировать пакет fmt:

``` go
import "fmt"
```
Нередко программы подключают сразу несколько внешних пакетов. В этом случае можно последовательно импортировать каждый пакет:

``` go
package main
import "fmt"
import "math"

func main() {

    fmt.Println(math.Sqrt(16))  // 4
}
```
В данном случае подключается встроенный пакет math, который содержит функцию Sqrt(), возвращающую квадратный корень числа.

Либо чтобы сократить определение импорта пакетов можно заключить все пакеты в скобки:

``` go
package main
import (
"fmt"
"math"
)

func main() {

    fmt.Println(math.Sqrt(16))
}
```
## Пакет из нескольких файлов
Один пакет может состоять из нескольких файлов. Например, определим в папке два файла:

Multiple files in Go build
В файле factorial.go определим функцию для подсчета факториала:

``` go
package main

func factorial(n int) int {

    var result = 1
    for i:=1; i <= n; i++{
        result *= i
    }
    return result
}
```
Данный файл принадлежит пакету main.

В файле main.go используем функцию для вычисления факториала:

``` go
package main
import "fmt"

func main() {

    fmt.Println(factorial(4))
    fmt.Println(factorial(5))
}
```
Данный файл также принадлежит пакету main. Файлов может и быть и больше. Теперь скомпилируем из этих файлов программу. Для этого перейдем в консоли к папке проекта и выполним команду:

`go build -o main.exe factorial.go main.go`

Флаг -o указывает, как будет называться выходной файл - в данном случае main.exe. Затем идут все компилируемые файлы. После выполнения этой команды будет создан файл main.exe, который мы сможем запустить в консоли:

## Компиляция файлов Go
Файлы в разных пакетах
Теперь рассмотрим другую ситуацию, когда файлы нашей программы разделены по разным пакетам. Определим в папке проекта каталог computation. Затем в каталог computation добавим следующий файл factorial.go:

``` go
package computation

func Factorial(n int) int {

    var result = 1
    for i:=1; i <= n; i++{
        result *= i
    }
    return result
}
```
Код файла factorial.go принадлежит пакету computation. Важно отметить, что название функции начинается с заглавной буквы. Благодаря этому данная функция будет видна в других пакетах.

## Импорт пакетов в Go
И чтобы использовать функцию factorial, надо импортировать этот пакет в файле main.go:

``` go
package main
import (
"fmt"
"./computation"
)

func main() {

    fmt.Println(computation.Factorial(4))
    fmt.Println(computation.Factorial(5))
}
```
Путь "./computation" указывает, что пакет находится в папке computation.

Компиляция и выполнение программы осуществляется также как и ранее без необходимости указания всех файлов из других пакетов

# Gitflow

## Понятие Git flow
Git-flow представляет собой стратегию работы с ветками и процессами в системе управления версиями, которая упрощает и структурирует распределение задач и выпуск новых версий проекта. Этот подход упрощает как индивидуальную, так и командную работу, предоставляя четкие инструкции по организации кода.

Основная идея подхода заключается во введении различных веток для выполнения разных задач. Каждый тип ветки выполняет свою определенную роль в процессе разработки и выпуска программного обеспечения.

- Ветка разработки (develop): является основной для разработки, сюда интегрируются все изменения от разработчиков.
- Основная ветка (main): хранится стабильная версия продукта, которая готова к выпуску.
- Фичевые ветки (feature): создаются для работы над новыми возможностями или улучшениями, после завершения соединяются с веткой разработки.
- Релизные ветки (release): ответственные за подготовку к выпуску нового релиза, содержат фиксы и стабилизирующие изменения.
- Хотфиксы (hotfix): используются для быстрого исправления критических ошибок в основной ветке.

## Структура веток
Модель ветвления позволяет эффективно управлять кодом и гарантирует стабильность проекта, минимизируя риски и улучшая качество результатов.

Структура веток является основой для эффективного управления и координации работы в команде разработчиков. Она позволяет четко разграничить различные этапы и типы работ, создавая логичное и удобное оформление проекта. Давайте рассмотрим основные типы веток и их назначение.

- Основная (main, master)Содержит стабильную и готовую к релизу версию проекта. Изменение здесь происходит редко и только после тщательного тестирования.
- Разработка (develop)	Используется для объединения всех изменений, которые будут включены в следующий релиз. Ветки функционала вливаются сюда после завершения работы над ними.
- Функциональные (feature)	Предназначены для разработки новых функций или задач. Создаются из ветки разработки и вливаются обратно по завершению.
- Релизные (release)	Формируются перед выпуском новой версии. Из этой ветки устраняются последние баги и подготавливаются релизные версии.
- Исправление ошибок (hotfix)	Используются для быстрого исправления критических ошибок в основной ветке. Создаются из основной ветки и после устранения проблемы изменения вливаются обратно в основную и ветку разработки.

## Основные правила
Цель модели - упрощение управления кодом посредством рационального разделения веток и обязательных действий при работе с ними.

Рассмотрим основные правила работы с данной моделью:

- Использование веток. Каждая функциональность, исправление или новая особенность разрабатывается в отдельной ветке. Это помогает изолировать изменения и избегать конфликтов.
- Структура веток. Существует несколько типов веток: главная (master), разработческая (develop), функциональные (feature), релизные (release) и ветви исправлений (hotfix). Все они выполняют определенные задачи в процессе разработки.
- Объединение изменений. Ветки функциональностей объединяются с веткой разработчиков только после завершения и тестирования. Это позволяет сохранять стабильность основной ветки.
- Тестирование и качество кода. Перед слиянием изменений в главную ветку все коды проходят обязательное тестирование. Это предотвращает попадание некачественных или нестабильных исправлений.
- Документирование. Каждая ветка и ее изменения должны быть документированы в системе управления версиями. Это облегчает отслеживание изменений и понимание истории разработки.

## Преимущества использования
Использование структурированной модели позволяет значительно упростить работу с кодом, повышая эффективность и качество конечного продукта.

Рассмотрим основные плюсы от применения данной модели при разработке:

- Структурирование работы: Модель на базе веток облегчает распределение задач и упорядочивает процесс разработки. Это позволяет команде сосредоточиться на конкретных задачах, сохраняя общую картину проекта.
- Улучшение сотрудничества: Каждый разработчик может работать в своей ветке, не мешая другим. Это повышает производительность и уменьшает риск конфликта изменений в коде.
- Контроль над качеством: Возможность тестирования изменений в отдельных ветках перед их слиянием с основной веткой обеспечивает высокий уровень качества. Ошибки можно выявлять и исправлять на ранних этапах.
- Легкость в отслеживании изменений: Использование именованных веток упрощает отслеживание версий кода и анализа исторических изменений. Это позволяет быстро определить, где и когда были внесены конкретные изменения.
- Гибкость при разработке: Разработка может продолжаться параллельно в несколько этапов, что позволяет реализовывать новые функции и исправления вне зависимости от других задач.
