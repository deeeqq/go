# SOLID

Это наиболее известный принцип разработки ПО. Solid — это аббревиатура от:

## S) Single-responsibility principle /Принцип единственной ответственности

Его важность невозможно переоценить. Каждый объект, класс и метод должны отвечать только за что-то одно. Если ваш объект/класс/метод делает слишком много, вы получите спагетти-код. Вот пример:
``` go
const saveTodo = async () => {
try {
response = await saveTodoApi();
showSuccessPop('Success');
window.location.href = '/successPage';
} catch (error) {
showErrorPopup(`Error: ${error} `);
}
}
```
Этот метод кажется безобидным, но на самом деле он делает слишком много:

Сохраняет объект
Обрабатывает уведомление в UI
Выполняет навигацию

Еще один побочный эффект такого кода – проблемы с тестированием. Запутанный функционал тестировать сложно.

## O) Open–closed principle / Принцип открытости-закрытости

Программные объекты должны быть открыты для расширения, но закрыты для модификации. Речь о том, что нельзя переопределять методы или классы, просто добавляя дополнительные функции по мере необходимости.

Хороший способ решения этой проблемы – использование наследования. В JavaScript эта проблема решается с помощью композиции.

Простое правило: если вы изменяете сущность, чтобы сделать ее расширяемой, вы впервые нарушили этот принцип.

## L) Liskov substitution principle / Принцип подстановки Лисков

Этот принцип гласит, что объекты старших классов должны быть заменимы объектами подклассов, и приложение при такой замене должно работать так, как ожидается.

## I) Interface segregation principle / Принцип разделения интерфейсов

Этот принцип был сформулирован Робертом Мартином, когда он консультировал Xerox, и он очевиден.

Объекты не должны зависеть от интерфейсов, которые они не используют


ПО должно разделяться на независимые части. Побочные эффекты необходимо сводить к минимуму, чтобы обеспечивать независимость.

Убедитесь, что вы не заставляете объекты реализовывать методы, которые им никогда не понадобятся. Вот пример:
``` go
interface Animal {
eat: () => void;
walk: () => void;
fly: () => void;
swim: () => void;
}
```
Не все животные могут fly, walk или swim, поэтому эти методы не должны быть частью интерфейса или должны быть необязательными.

## D) Dependency inversion principle / Принцип инверсии зависимостей

Этот принцип невозможно переоценить. Мы должны полагаться на абстракции, а не на конкретные реализации. Компоненты ПО должны иметь низкую связность и высокую согласованность.

Заботиться нужно не о том, как что-то устроено, а о том, как оно работает. Простой пример – использование дат в JavaScript. Вы можете написать для них свой слой абстракции. Тогда если у вас сменится источник получения дат, вам нужно будет внести изменения в одном месте, а не в тысяче.

Иногда добавление этого уровня абстракции требует усилий, но в конечном итоге они окупаются.

В качестве примера взгляните на date-io, в этой библиотеке создан тот уровень абстракции, который позволяет вам использовать её с разными источниками дат.

# KISS
Keep It Simple, Stupid / Будь проще

Этот принцип был разработан ВМС США в 1960 году. Этот принцип гласит, что простые системы будут работать лучше и надежнее.

У этого принципа много общего с переизобретением колеса, которым занимались в 1970-х. Тогда он звучал как деловая и рекламная метафора.

Применительно к разработке ПО он значит следующее – не придумывайте к задаче более сложного решения, чем ей требуется.

Иногда самое разумное решение оказывается и самым простым. Написание производительного, эффективного и простого кода – это прекрасно.

Одна из самых распространенных ошибок нашего времени – использование новых инструментов исключительно из-за того, что они блестят. Разработчиков следует мотивировать использовать новейшие технологии не потому, что они новые, а потому что они подходят для работы.

# DRY
Don’t Repeat Yourself / Не повторяйтесь

Эта концепция была впервые сформулирована в книге Энди Ханта и Дэйва Томаса «Программист-прагматик: путь от подмастерья к мастеру».

Идея вращается вокруг единого источника правды (single source of truth — SSOT). Что это вообще такое?

В проектировании и теории информационных систем единый источник истины (SSOT) – это практика структурирования информационных моделей и схемы данных, которая подразумевает, что все фрагменты данных обрабатываются (или редактируются) только в одном месте… SSOT предоставляют достоверные, актуальные и пригодные к использованию данные.


# Пакеты и модули
## Пакеты и их импорт

Использование SSOT позволит создать более прочную и понятную кодовую базу.

Дублирование кода – пустая трата времени и ресурсов. Вам придется поддерживать одну и ту же логику и тестировать код сразу в двух местах, причем если вы измените код в одном месте, его нужно будет изменить и в другом.

В большинстве случаев дублирование кода происходит из-за незнания системы. Прежде чем что-либо писать, проявите прагматизм: осмотритесь. Возможно, эта функция где-то реализована. Возможно, эта бизнес-логика существует в другом месте. Повторное использование кода – всегда разумное решение.


Весь код в языке Go организуется в пакеты. Пакеты представляют удобную организацию разделения кода на отдельные части или модули. Модульность позволяет определять один раз пакет с нужной функциональностью и потом использовать его многкратно в различных программах.

Код пакета располагается в одном или нескольких файлах с расширением go. Для определения пакета применяется ключевое слово package. Например:

``` go
package main
import "fmt"

func main() {

    fmt.Println("Hello Go")
}
```
В данном случае пакет называется main. Определение пакета должно идти в начале файла.

Есть два типа пакетов: исполняемые (executable) и библиотеки (reusable). Для создания исполняемых файлов пакет должен иметь имя main. Все остальные пакеты не являются исполняемыми. При этом пакет main должен содержать функцию main, которая является входной точкой в приложение.

## Импорт пакетов
Если уже есть готовые пакеты с нужной нам функциональностью, которую мы хотим использовать, то для их использования мы можем их импортировать в программу с помощью оператора import. Например, в примере выше задействуется функциональность вывода сообщения на консоль с помощью функции Println, которая определена в пакете fmt. Соответственно чтобы использовать эту функцию, необходимо импортировать пакет fmt:

``` go
import "fmt"
```
Нередко программы подключают сразу несколько внешних пакетов. В этом случае можно последовательно импортировать каждый пакет:

``` go
package main
import "fmt"
import "math"

func main() {

    fmt.Println(math.Sqrt(16))  // 4
}
```
В данном случае подключается встроенный пакет math, который содержит функцию Sqrt(), возвращающую квадратный корень числа.

Либо чтобы сократить определение импорта пакетов можно заключить все пакеты в скобки:

``` go
package main
import (
"fmt"
"math"
)

func main() {

    fmt.Println(math.Sqrt(16))
}
```
## Пакет из нескольких файлов
Один пакет может состоять из нескольких файлов. Например, определим в папке два файла:

Multiple files in Go build
В файле factorial.go определим функцию для подсчета факториала:

``` go
package main

func factorial(n int) int {

    var result = 1
    for i:=1; i <= n; i++{
        result *= i
    }
    return result
}
```
Данный файл принадлежит пакету main.

В файле main.go используем функцию для вычисления факториала:

``` go
package main
import "fmt"

func main() {

    fmt.Println(factorial(4))
    fmt.Println(factorial(5))
}
```
Данный файл также принадлежит пакету main. Файлов может и быть и больше. Теперь скомпилируем из этих файлов программу. Для этого перейдем в консоли к папке проекта и выполним команду:

`go build -o main.exe factorial.go main.go`

Флаг -o указывает, как будет называться выходной файл - в данном случае main.exe. Затем идут все компилируемые файлы. После выполнения этой команды будет создан файл main.exe, который мы сможем запустить в консоли:

## Компиляция файлов Go
Файлы в разных пакетах
Теперь рассмотрим другую ситуацию, когда файлы нашей программы разделены по разным пакетам. Определим в папке проекта каталог computation. Затем в каталог computation добавим следующий файл factorial.go:

``` go
package computation

func Factorial(n int) int {

    var result = 1
    for i:=1; i <= n; i++{
        result *= i
    }
    return result
}
```
Код файла factorial.go принадлежит пакету computation. Важно отметить, что название функции начинается с заглавной буквы. Благодаря этому данная функция будет видна в других пакетах.

## Импорт пакетов в Go
И чтобы использовать функцию factorial, надо импортировать этот пакет в файле main.go:

``` go
package main
import (
"fmt"
"./computation"
)

func main() {

    fmt.Println(computation.Factorial(4))
    fmt.Println(computation.Factorial(5))
}
```
Путь "./computation" указывает, что пакет находится в папке computation.

Компиляция и выполнение программы осуществляется также как и ранее без необходимости указания всех файлов из других пакетов

# Gitflow

## Понятие Git flow
Git-flow представляет собой стратегию работы с ветками и процессами в системе управления версиями, которая упрощает и структурирует распределение задач и выпуск новых версий проекта. Этот подход упрощает как индивидуальную, так и командную работу, предоставляя четкие инструкции по организации кода.

Основная идея подхода заключается во введении различных веток для выполнения разных задач. Каждый тип ветки выполняет свою определенную роль в процессе разработки и выпуска программного обеспечения.

- Ветка разработки (develop): является основной для разработки, сюда интегрируются все изменения от разработчиков.
- Основная ветка (main): хранится стабильная версия продукта, которая готова к выпуску.
- Фичевые ветки (feature): создаются для работы над новыми возможностями или улучшениями, после завершения соединяются с веткой разработки.
- Релизные ветки (release): ответственные за подготовку к выпуску нового релиза, содержат фиксы и стабилизирующие изменения.
- Хотфиксы (hotfix): используются для быстрого исправления критических ошибок в основной ветке.

## Структура веток
Модель ветвления позволяет эффективно управлять кодом и гарантирует стабильность проекта, минимизируя риски и улучшая качество результатов.

Структура веток является основой для эффективного управления и координации работы в команде разработчиков. Она позволяет четко разграничить различные этапы и типы работ, создавая логичное и удобное оформление проекта. Давайте рассмотрим основные типы веток и их назначение.

- Основная (main, master)Содержит стабильную и готовую к релизу версию проекта. Изменение здесь происходит редко и только после тщательного тестирования.
- Разработка (develop)	Используется для объединения всех изменений, которые будут включены в следующий релиз. Ветки функционала вливаются сюда после завершения работы над ними.
- Функциональные (feature)	Предназначены для разработки новых функций или задач. Создаются из ветки разработки и вливаются обратно по завершению.
- Релизные (release)	Формируются перед выпуском новой версии. Из этой ветки устраняются последние баги и подготавливаются релизные версии.
- Исправление ошибок (hotfix)	Используются для быстрого исправления критических ошибок в основной ветке. Создаются из основной ветки и после устранения проблемы изменения вливаются обратно в основную и ветку разработки.

## Основные правила
Цель модели - упрощение управления кодом посредством рационального разделения веток и обязательных действий при работе с ними.

Рассмотрим основные правила работы с данной моделью:

- Использование веток. Каждая функциональность, исправление или новая особенность разрабатывается в отдельной ветке. Это помогает изолировать изменения и избегать конфликтов.
- Структура веток. Существует несколько типов веток: главная (master), разработческая (develop), функциональные (feature), релизные (release) и ветви исправлений (hotfix). Все они выполняют определенные задачи в процессе разработки.
- Объединение изменений. Ветки функциональностей объединяются с веткой разработчиков только после завершения и тестирования. Это позволяет сохранять стабильность основной ветки.
- Тестирование и качество кода. Перед слиянием изменений в главную ветку все коды проходят обязательное тестирование. Это предотвращает попадание некачественных или нестабильных исправлений.
- Документирование. Каждая ветка и ее изменения должны быть документированы в системе управления версиями. Это облегчает отслеживание изменений и понимание истории разработки.

## Преимущества использования
Использование структурированной модели позволяет значительно упростить работу с кодом, повышая эффективность и качество конечного продукта.

Рассмотрим основные плюсы от применения данной модели при разработке:

- Структурирование работы: Модель на базе веток облегчает распределение задач и упорядочивает процесс разработки. Это позволяет команде сосредоточиться на конкретных задачах, сохраняя общую картину проекта.
- Улучшение сотрудничества: Каждый разработчик может работать в своей ветке, не мешая другим. Это повышает производительность и уменьшает риск конфликта изменений в коде.
- Контроль над качеством: Возможность тестирования изменений в отдельных ветках перед их слиянием с основной веткой обеспечивает высокий уровень качества. Ошибки можно выявлять и исправлять на ранних этапах.
- Легкость в отслеживании изменений: Использование именованных веток упрощает отслеживание версий кода и анализа исторических изменений. Это позволяет быстро определить, где и когда были внесены конкретные изменения.
- Гибкость при разработке: Разработка может продолжаться параллельно в несколько этапов, что позволяет реализовывать новые функции и исправления вне зависимости от других задач.


# Интерфейсы
Интерфейсы представляют абстракцию поведения других типов. Интерфейсы позволяют определять функции, которые не привязаны к конкретной реализации. То есть интерфейсы определяют некоторый функционал, но не реализуют его.

Для определения интерфейса применяется ключевое слово interface:

``` go
type имя_интерфейса interface{
определения_функций
}
``` 
Например, простейшее определение интерфейса:

``` go
type vehicle interface{
move()
}
``` 
Данный интерфейс называется vehicle. Допустим, данный интерфейс представляет некоторое транспортное средство. Он определяет функцию move(), которая не принимает никаких параметров и ничего не возвращает.

Переменные интерфейсов
Как и в случае с переменными структур мы можем определить переменную, которая представляет тип интерфейса:

``` go
package main

import "fmt"

type Vehicle interface{
move()
}

func main() {

    var tesla Vehicle   // переменная интерфейса
    fmt.Println(tesla)  // nil
}
``` 
Мы можем даже попробовать вывести переменную интерфейса на консоль, но в данном случае переменная по умолчанию равна nil, так как мы еще не присвоили ей никакого значения.

При этом важно понимать, что интерфейс - это именно абстракция, а не конкретный тип, как int, sring или структуры. К примеру, мы НЕ можем напрямую создать объект интерфейса:

``` go
var v vehicle = vehicle{}
``` 
## Реализация интерфейса
Реализуем выше определенный интерфейс и для этого определим две структуры:
``` go
package main

import "fmt"

type Vehicle interface{
move()
}

// структура "Автомобиль"
type Car struct{ }

// структура "Самолет"
type Aircraft struct{}


func (c Car) move(){
fmt.Println("Автомобиль едет")
}
func (a Aircraft) move(){
fmt.Println("Самолет летит")
}

func main() {

    var tesla Vehicle = Car{}
    var boing Vehicle = Aircraft{}
    tesla.move()    // Автомобиль едет
    boing.move()    // Самолет летит
}
``` 
Здесь определены две структуры: Car и Aircraft, которые, предположим, представляют, автомобиль и самолет соответственно. Для каждой из структур определен метод move(), который имитирует перемещение транспортного средства. Этот метод move соответствует функции move интерфейса vehicle по типу параметров и типу возвращаемых значений. Поскольку между методом структур и функций в интерфейсе есть соответствие, то подобные структуры неявно реализуют данный интерфейс.

В Go интерфейс реализуется неявно. Нам не надо специально указывать, что структуры применяют определенный интерфейс, как в некоторых других языках программирования. Для реализации типу данных достаточно реализовать методы, которые определяет интерфейс.

Поскольку структуры Car и Aircraft реализуют интерфейс Vehicle, то мы можем определить переменные данного интерфейса, передав им объекты структур:

``` go
var tesla Vehicle = Car{}
var boing Vehicle = Aircraft{}
``` 
Где нам могут помочь интерфейсы? Интерфейсы позволяют определить какую-то обобщенную реализацию без привязки к конкретному типу. Например, рассмотрим следующую ситуацию:

``` go
package main

import "fmt"

type Car struct{ }
type Aircraft struct{}


func (c Car) move(){
fmt.Println("Автомобиль едет")
}
func (a Aircraft) move(){
fmt.Println("Самолет летит")
}

func driveCar(c Car){
c.move()
}
func driveAircraft(a Aircraft){
a.move()
}

func main() {

    var tesla Car = Car{}
    var boing Aircraft = Aircraft{}
    driveCar(tesla)
    driveAircraft(boing)
}
``` 
Допустим, в данном случае определены две структуры Car и Aircraft, которые представляют автомобиль и самолет. Для каждой из структур определен метод перемещения move(), который условно перемещает транспортное средство. И также определены две функции driveCar() и driveAircraft(), которые принимают соответственно структуры Car и Aircraft и предназначены для вождения этих транспортных средств.

И отчетливо видно, что обе функции driveCar и driveAircraft фактически идентичны, они выполняют один и те же действия, только для разных типов. И было бы неплохо, если можно было бы определить одну обобщенную функцию для разных типов. Особенно учитывая, что у нас может быть и больше транспортных средств - велосипед, корабль и т.д. И для вождения каждого транспортного средства придется определять свой метод, что не очень удобно. И как раз в этом случае можно воспользоваться интерфейсами:

``` go
package main
import "fmt"

type Vehicle interface{
move()
}

func drive(vehicle Vehicle){
vehicle.move()
}

type Car struct{ }
type Aircraft struct{}


func (c Car) move(){
fmt.Println("Автомобиль едет")
}
func (a Aircraft) move(){
fmt.Println("Самолет летит")
}

func main() {

    tesla := Car{}
    boing := Aircraft{}
    drive(tesla)
    drive(boing)
}
``` 
Теперь вместо двух функций определена одна общая функция - drive(), которая в качесте параметра принимает значение типа Vehicle. Поскольку этому интерфейсу соответствуют обе структуры Car и Aircraft, то мы можем передавать эти структуры в функцию drive в качесте аргументов.

## Соответствие интерфейсу
Чтобы тип данных соответствовал интерфейсу, он должен реализовать все методы этого интерфейса. Например:

``` go

// интерфейс перемещения объекта
type Movable interface{
moveX(distance int)
moveY(distance int)
}

type Rectangle struct{ }

// реализация интерфейса Movable для Rectangle
func (r Rectangle) moveX(distance int){
fmt.Println("Перемещаем прямоугольник на ", distance, " по оси X")
}

// функция перемещения объекта Movable
func move_object(obj Movable) {
obj.moveX(10)
}

func main() {

    rect := Rectangle{} 
    move_object(rect)  // Перемещаем прямоугольник
}
``` 
Здесь определен интерфейс Movable с двумя методами - moveX (для перемещения по оси X) и moveY (для перемещения по оси Y). Структура Rectangle реализует только один из этих методов. И если мы попробуем передать значение этой структуры в функцию move_object, которая принимает интерфейс Movable:

``` go
func move_object(obj Movable) {
obj.moveX(10)
}

func main() {

    rect := Rectangle{} 
    move_object(rect)  // Перемещаем прямоугольник
}
``` 
То мы получим ошибку. Так как, чтобы соответствовать интерфейсу Movable структура Rectangle должна реализовать оба метода:

``` go
package main
import "fmt"

type Movable interface{
moveX(distance int)
moveY(distance int)
}

type Rectangle struct{ }


func (r Rectangle) moveX(distance int){
fmt.Println("Перемещаем прямоугольник на ", distance, " по оси X")
}
// добавляем реализацию метода moveY
func (r Rectangle) moveY(distance int){
fmt.Println("Перемещаем прямоугольник на ", distance, " по оси Y")
}

func move_object(obj Movable) {
obj.moveX(10)
}

func main() {

    rect := Rectangle{} 
    move_object(rect)  // Перемещаем прямоугольник
}
``` 
## Пустой интерфейс
Интерфейс, который не содержит ни одного метода, называется пустым интерфейсом. Поскольку каждый тип реализует ноль методов, пустой интерфейс может содержать любое значение. В программировании часто встречаются случаи, когда нет уверенности в типе значения. Для обработки таких случаев используются пустые интерфейсы. Функция print является лучшим примером пустых интерфейсов, которые используются для печати любого значения. Например:

``` go
package main

import "fmt"

// пустой интерфейс
type Empty interface{ }

func print_value(value Empty){
fmt.Println(value)
}

type person struct{
name string
}

type account struct{
id int
}

func main() {

    tom :person{"Tom"} 
 
    tom_acc := account{125} 
 
    print_value(tom) // {Tom} 
 
    print_value(tom_acc) // {125}
}
``` 
Здесь мы создаем две структуры с двумя полями. Интерфейс Empty не имеет ни одного метода. Метод print_value принимает пустой интерфейс Empty, который может содержать любое значение. Значение такого пустого интерфейса называется его динамическим или конкретным значением.

## Полиморфизм
Интерфейсы в языке Go позволяют реализовать концепцию полиморфизма - способность принимать многообразные формы: есть несколько типов, которые имеют одни и те же методы интерфейса, но по разному их реализуют. То есть имеется один и тот же функционал и множество форм его реализации, и поведение интерфейса изменяется в соответствии с типом, который реализует интерфейс

В частности, ранее было рассмотрено использование интерфейсов, которым могут соответствовать различные структуры. Например:
``` go
package main
import "fmt"

type Vehicle interface{
move()
}

type Car struct{ model string}
type Aircraft struct{ model string}


func (c Car) move(){
fmt.Println(c.model, "едет")
}
func (a Aircraft) move(){
fmt.Println(a.model, "летит")
}

func main() {

    tesla := Car{"Tesla"}
    volvo := Car{"Volvo"}
    boeing := Aircraft{"Boeing"}
     
    vehicles := [...]Vehicle{tesla, volvo, boeing}
    for _, vehicle := range vehicles{
        vehicle.move()
    }
}
``` 
В данном случае определен массив vehicles, который содержит набор структур, которые соответствуют интерфейсу Vehicle, то есть объекты Car и Aircraft. То есть объект Vehicle может принимать различные формы: или структуру Car, или структуру Aircraft. При переборе массива для каждого объекта вызывается метод move. И в зависимости от реального типа структуры динамически определяется, какая именно реализация метода move для какой структуры должна вызываться.

Консольный вывод программы:
``` go
Tesla едет
Volvo едет
Boeing летит
``` 
Интерфейс представляет своего рода контракт, которому должен соответствовать тип данных. Чтобы тип данных соответствовал некоторому интерфейсу, данный тип должен реализовать в виде методов все функции этого интерфейса.
Реализация интерфейсов для указателей структур
Последнее обновление: 21.06.2025

## Реализация интерфейсов в структурах распространяется и на указатели на эти структуры. То есть мы можем передавать указатель на структуру там, где требуется интерфейс:

``` go
package main

import "fmt"

type Reader interface{
read()
}

type File struct{
text string
}

// реализация интерфейса Reader для File
func (f File) read(){
fmt.Println(f.text)
}

// функция перемещения объекта Movable
func read_data(data Reader) {
data.read()
}

func main() {

    file := File{"Hello METANIT.COM"}
    // так можно
    read_data(file)
 
    p_file := &file  // указатель на File
    // и так можно
    read_data(p_file)
}
``` 
В данном случае структура File реализует интерфейс чтения данных Reader. Для теста определена функция read_data, которая получает объект Reader. И в эту функцию мы можем передать как значение File, так и указатель на эту структуру.

Тем не менее в Go мы можем реализовать интерфейсы отдельно для указателей на структур:

``` go
package main

import "fmt"

type Reader interface{
read()
}

type File struct{
text string
}

// реализация интерфейса Reader для *File
func (f *File) read(){
fmt.Println(f.text)
}

// функция перемещения объекта Movable
func read_data(data Reader) {
data.read()
}

func main() {

    file := File{"Hello METANIT.COM"}
    p_file := &file  // указатель на File
 
    // указатель можно передать
    read_data(p_file)
 
    // а так нельзя
    // read_data(file)   // ! Ошибка
}
``` 
На первый взгляд здесь у нас та же самая программа. Но теперь метод read интерфейса Reader реализуется только для указателя на File (но не для самой структуры File):

``` go
func (f *File) read(){
fmt.Println(f.text)
}
``` 
Поэтому мы можем передать в функцию read_data указатель на File:

``` go
read_data(p_file)
``` 
А непосредственно саму структур File передать нельзя:

``` go
read_data(file)  // ! Ошибка
``` 
То есть в данном случае тип File НЕ соответствует интерфейсу Reader, ему соответствует только указатель на File.

Реализация интерфейсов для указателей может быть полезна, когда нам надо изменять поля структуры. Например:

``` go
package main
import "fmt"


type Writer interface{
write(string)
}

type File struct{
text string
}

// реализация интерфейса Writer для *File
func (f File) write(message string){
f.text = message  // изменяем поле text
fmt.Println("Запись в файл строки", message)
}

func main() {

    myFile := File{"Undefined"}
    myFile.write("Hello World")
    fmt.Println(myFile.text)  // Undefined
}
``` 
Здесь определен интрефейс Writer с методом write. В реализации этого метода для типа File мы изменяем значение поля text. Но есили мы запустим программу, мы увидим, что поле text не изменилось:

Запись в файл строки Hello World
Undefined
Теперь изменим реализацию с типа File на *File (указатель на File):

``` go
package main
import "fmt"


type Writer interface{
write(string)
}

type File struct{
text string
}

// реализация интерфейса Writer для *File
func (f *File) write(message string){
f.text = message
fmt.Println("Запись в файл строки", message)
}

func main() {

    myFile := File{"Undefined"}
    myFile.write("Hello World")
    fmt.Println(myFile.text)  // Hello World
}
``` 
И теперь значение поля text будет меняться.
## Множественная реализация интерфейсов
### Реализация нескольких интерфейсов
При этом тип данных необязательно должен реализовать только методы интерфейса, для типа данных можно определить его собственные методы или также реализовать методы других интерфейсов. Например:

``` go
package main
import "fmt"

// интерфейс перемещения объекта
type Movable interface{
move()
}

// интерфейс отрисовки объекта
type Drawable  interface{
draw()
}

type Rectangle struct{ }

// реализация интерфейса Movable для Rectangle
func (r Rectangle) move(){
fmt.Println("Перемещаем прямоугольник")
}
// реализация интерфейса Drawable для Rectangle
func (r Rectangle) draw(){
fmt.Println("Рисуем прямоугольник" )
}


func move_object(obj Movable) {
obj.move()
}

func draw_object(obj Drawable) {
obj.draw()
}

func main() {

    rect := Rectangle{}
    move_object(rect)  // Перемещаем прямоугольник
    draw_object(rect)   // Рисуем прямоугольник
 
    // или так
    var movable1 Movable = rect
    move_object(movable1) 
 
    var drawable1 Drawable = rect
    draw_object(drawable1) 
}
``` 
Здесь определены два интерфейса. Интерфейс Movable определяет функционал для перемещения объекта в виде метода move. Второй интерфейс - Drawable определяет метод draw для отрисовки объекта. В данном случае для типа Rectangle реализованы методы обоих интерфейсов - Drawable и Movable. Соответственно мы можем использовать объекты типа Rectangle в качестве объектов Movable (например, передать в функцию move_object) и Drawable (в функции draw_object).

### Вложенные интерфейсы
Язык Go не поддерживает наследование, но позволяет встраивать одни интерфейсы в другие. Интерфейс может содержать несколько интерфейсов или любую конкретную сигнатуру метода интерфейса. Это некоторым образом работает как наследование, поскольку мы получаем реализацию метода из другого интерфейса. Пример вложенных интерфейсов:

``` go
type Reader interface{
read()
}

type Writer interface{
write(string)
}

type ReaderWriter interface{
Reader
Writer
}
``` 
В этом случае для соответствия подобному интерфейсу типы данных должны реализовать все его вложенные интерфейсы. Например:

``` go
package main

import "fmt"

type Reader interface{
read()
}

type Writer interface{
write(string)
}

type ReaderWriter interface{
Reader
Writer
}

type File struct{
text string
}

func (f *File) read(){
fmt.Println(f.text)
}
func (f *File) write(message string){
f.text = message
fmt.Println("Запись в файл строки", message)
}

func main() {

    myFile := &File{}
    myFile.write("Hello METANIT.COM")
    myFile.read()
    myFile.write("Hello World")
    myFile.read()
}
``` 
В данном случае определено три интерфейса. Причем интерфейс ReaderWriter содержит интерфейсы Reader и Writer. Чтобы структура File соответствовала интерфейсу ReaderWriter, она должна реализовать методы read и write, то есть методы обоих вложенных интерфейсов, что в принципе здесь и сделано.

При этом вместо вложенного интерфейса мы можем прописать сигнатуры его методов:

``` go
package main

import "fmt"

type Reader interface{
read()
}

type Writer interface{
write(string)
}

type ReaderWriter interface{
Reader
write(string) // неявно встраивается интерфейс Writer
}

type File struct{
text string
}

func (f *File) read(){
fmt.Println(f.text)
}
func (f *File) write(message string){
f.text = message
fmt.Println("Запись в файл строки", message)
}

func writeToStream(writer Writer, text string){
writer.write(text)
}

func main() {

    myFile := &File{}
    writeToStream(myFile, "Hello METANIT.COM")
    myFile.read()
}
``` 
Теперь интерфейс ReaderWriter вместо интерфейса Writer содержит его метод write(). Тем самым интерфейс Writer также встраивается в ReaderWriter, только неявно:

``` go
type ReaderWriter interface{
Reader
write(string) // неявно встраивается интерфейс Writer
}
``` 
Соответственно если структура реализует этот метод, то она также реализует и интерфейс Writer и ReaderWriter. Поэтому структуру File, которая реализует метод write, можно использовать как значение интерфейса Writer, например, в функции writeToStream:

``` go
func writeToStream(writer Writer, text string){
writer.write(text)
}

func main() {

    myFile := &File{}
    writeToStream(myFile, "Hello METANIT.COM")
    myFile.read()
}
``` 
## Проверка типа интерфейса
### Type assertion (подтверждение типа)
В языке Go есть механизм type assertion - специальная конструкция, которая проверяет, содержит ли значение интерфейса указанный тип или нет, то есть выполняет подтверждение типа. Если значение интерфейса содержит данный конкретный тип, то возвращается true и значение данного конкретного типа; иначе возвращается false и ноль в качестве значения. Синтаксис подтверждения типа:
``` go
t, ok := i.(T)
``` 
Конструкция проверяет интерфейс i на наличие конкретного значения типа T. Подтверждение типа возвращает два значения, ok и t. Если интерфейс содержит значение типа T, то t получает это значение типа T, а ok равно true. Если интерфейс не содержит никакого значения типа T, то переменной t будет присвоен ноль, а ok будет равен false.

Рассмотрим применение:

``` go
package main
import "fmt"

// интерфейс перемещения объекта
type Movable interface{
move()
}

type Rectangle struct{
x,          // X-координата левого верхнего угла
y,          // Y-координата левого верхнего угла
width,      // ширина
height int  // высота
}

type Circle struct{
x,           // X-координата центра круга
y,           // Y-координата центра круга
radius int  // радиус круга
}

// реализация интерфейса Movable для Rectangle
func (r Rectangle) move(){
fmt.Println("Перемещаем прямоугольник")
}

// реализация интерфейса Movable для Circle
func (c Circle) move(){
fmt.Println("Перемещаем круг")
}

func main() {

    var shape Movable = Rectangle{ x: 20, y: 10, width: 150, height: 100} 
    //move_object(shape)
 
    // проверяем, реализует ли структура Rectangle интерфейс Movable 
    value, ok := shape.(Rectangle) 
    fmt.Println(ok)  // true
    fmt.Println(value)  // {20 10 150 100}
}
``` 
Здесь мы проверяем, реализован ли интерфейс Movable определенным типом или нет. Мы создаем переменную интерфейса shape. А выражение value, ok := shape.(Rectangle) проверяет, реализован ли интерфейс типом Rectangle или нет. Поскольку здесь интерфейс реализован типом Rectangle, то выражение возвращает true для ,ok и присваивает значение структуры переменной value.

Если мы проверим следующие строки кода, это вызовет ошибку, поскольку sструктура Circle не реализует интерфейсе Movable:

``` go
var shape Movable = Rectangle{ x: 20, y: 10, width: 150, height: 100}

// проверяем, реализует ли структура Circle интерфейс Movable
value, ok := shape.(Circle)  // ! Ошибка
fmt.Println(ok, value)
``` 
### Проверка типа и Type switch

Мы можем использовать подряд несколько подтверждений типа, используя конструкцию Type switch. Эта конструкция использует оператор switch, сравнивая тип значения. Для проверки типа применяются операторы case, после которых указывается проверяемый тип, которому должно соответствовать значение интерфейса. Стоит помнить, что если переменной интерфейса не присвовано значение, то оно равно nil, а его тип тоже nil. Формальный синтаксис:

``` go
switch value := i.(type){

    case T1:        // Действия, если value представляет тип T1
 
    case T2:        // Действия, если value представляет тип T2
 
    .......................................................
    case TN:        // Действия, если value представляет тип TN
 
    default:    // если ни один из типов в case не соответствуют v
}
``` 
В этой конструкции i представляет интерфейс, type - проверяемый тип, а value — это значение интерфейса. Оператор switch проверяет, представляет ли value тип T1 или T2, и выполняет этот конкретный случай. Он выполняет действия после оператора default, если value не соответствует ни одному из типов после case.

Посмотрим применение конструкции на примере:

``` go
package main
import "fmt"

// интерфейс перемещения объекта
type Movable interface{
move()
}

type Rectangle struct{
x,          // X-координата левого верхнего угла
y,          // Y-координата левого верхнего угла
width,      // ширина
height int  // высота
}

type Circle struct{
x,           // X-координата центра круга
y,           // Y-координата центра круга
radius int  // радиус круга
}

type Point struct{
x,           // X-координата
y int   // Y-координата
}

// функция проверки типа
func check(i interface{}) {

    switch value := i.(type) {
 
        case Rectangle:
            fmt.Println("Type: Rectangle. Value: ", value)
 
        case Circle:
            fmt.Println("Type: Circle. Value: ", value)
 
        default:
            fmt.Println("Type: Undefined")
    }
}

func main() {

    check(Rectangle{ x: 20, y: 10, width: 150, height: 100} )
    check(Circle{ x: 80, y: 50, radius: 70} )
    check(Point{ x: 20, y: 10} )
}
``` 
Здесь определена вспомогательная функция check(), которая принимает произвольное значение. И тип этого значения последовательно сравнивается в конструкции switch с типами Rectangle и Circle. В итоге мы получим следующий консольный вывод:
``` go
Type: Rectangle. Value:  {20 10 150 100}
Type: Circle. Value:  {80 50 70}
Type: Undefined
``` 
# Generic

# Указатели

Указатели представляют собой объекты, значением которых служат адреса других объектов (например, переменных).

Указатель определяется как обычная переменная, только перед типом данных ставится символ звездочки `*`. Например, определение указателя на объект типа int:

``` go
var p *int
```
Этому указателю можно присвоить адрес переменной типа int. Для получения адреса применяется операция &, после которой указывается имя переменной (&x).

``` go
package main

import "fmt"

func main() {

    var x int = 4       // определяем переменную
    var p *int          // определяем указатель 
    p = &x              // указатель получает адрес переменной
    fmt.Println(p)      // значение самого указателя - адрес переменной x
}
```
Здесь указатель p хранит адрес переменной x. Что важно, переменная x имеет тип int, и указатель p указывает именно на объект типа int. То есть должно быть соответствие по типу. И если мы попробуем вывести адрес переменной на консоль, то увидим, что он представляет шестнадцатеричное значение:

`0xc0420120a0`

В каждом отдельном случае адрес может отличаться, но к примеру, в моем случае машинный адрес переменной x - 0xc0420120a0. То есть в памяти компьютера есть адрес 0xc0420120a0, по которому располагается переменная x.

По адресу, который хранит указатель, мы получить значение переменной x. Для этого применяется операция * или операция разыменования. Результатом этой операции является значение переменной, на которую указывает указатель. Применим данную операцию и получим значение переменной x:

``` go
package main

import "fmt"

func main() {

    var x int = 4
    var p *int  = &x                // указатель получает адрес переменной
    fmt.Println("Address:", p)      // значение указателя - адрес переменной x
    fmt.Println("Value:", *p)       // значение переменной x
}
```
Консольный вывод:
```
Address: 0xc0420c058
Value: 4
```
И также используя указатель, мы можем менять значение по адресу, который хранится в указателе:

``` go
var x int = 4
var p *int = &x
*p = 25
fmt.Println(x)      // 25
```
Для определения указателей можно использовать также сокращенную форму:

``` go
f := 2.3
pf := &f

fmt.Println("Address:", pf)
fmt.Println("Value:", *pf)
```
## Пустой указатель
Если указателю не присвоен адрес какого-либо объекта, то такой указатель по умолчанию имеет значение nil (по сути отстутствие значения). Если мы попробуем получить значение по такому пустому указателю, то мы столкнемся с ошибкой:

``` go
var pf *float64
fmt.Println("Value:", *pf)  // ! ошибка, указатель не указывает на какой-либо объект
```
Поэтому при работе с указателями иногда бывает целесообразано проверять на значение nil:

``` go
var pf *float64
if pf != nil{
fmt.Println("Value:", *pf)
}
```
## Функция new
Переменная представляет именованный объект в памяти. Язык Go также позволяет создавать безымянные объекты - они также размещаются в памяти, но не имеют имени как переменные. Для этого применяется функция new(type). В эту функцию передается тип, объект которого надо создать. Функция возвращает указатель на созданный объект:

``` go
package main

import "fmt"

func main() {

    p := new(int) 
    fmt.Println("Value:", *p)       // Value: 0 - значение по умолчанию
    *p = 8                          // изменяем значение
    fmt.Println("Value:", *p)       // Value: 8
}
```
В данном случае указатель p будет иметь тип *int, поскольку он указывает на объект типа int. Создаваемый объект имеет значение по умолчанию (для типа int это число 0).

Объект, созданный с помощью функции new, ничем не отличается от обычной переменной. Единственное что, чтобы обратиться к этому объекту - получить или изменить его адрес, необходимо использовать указатель.