# Структуры
Структуры представляют тип данных, определяемый разработчиком и служащий для представления каких-либо объектов. Структуры содержат набор полей, которые представляют различные атрибуты объекта. Для определения структуры применяются ключевые слова type и struct:

``` go
type имя_структуры struct{
поля_структуры
}
```
Каждое поле имеет название и тип данных, как переменная. Например, определим структуру, которая представляет человека:

``` go
type person struct{
name string
age int
}
```
Структура называется person. Она имеет два поля: name (имя человека, представляет тип string) и age (возраст человека, представляет тип int).

## Создание и инициализация структуры
Структура представляет новый тип данных, и мы можем определить переменную данного типа:

``` go
var tom person
```
С помощью инициализатора можно передать структуре начальные значения:

``` go
var tom person = person{"Tom", 23}
```
Инициализатор представляет набор значений в фигурных скобках. Причем эти значения передаются полям структуры в том порядке, в котором поля определены в структуре. Например, в данном случае строка "Tom" передается первому полю - name, а второе значение - 23 передается второму полю - age.

Также мы можем явным образом указать какие значения передаются свойствам:

``` go
var alice person = person{age: 23, name: "Alice"}
```
Также можно использовать сокращенные способы инициализации переменной структуры:

``` go
var tom = person {name: "Tom", age: 24}
bob := person {name: "Bob", age: 31}
```
Можно даже не указывать никаких значений, в этом случае свойства структуры получат значения по умолчанию:

``` go
undefined := person {}  // name - пустая строка, age - 0
```
## Обращение к полям структуры
Для обращения к полям структуры после переменной ставится точка и указывается поле структуры:

``` go
package main
import "fmt"

type person struct{
name string
age int
}

func main() {

    var tom = person {name: "Tom", age: 24}
    fmt.Println(tom.name)       // Tom
    fmt.Println(tom.age)        // 24
     
    tom.age = 38    // изменяем значение
    fmt.Println(tom.name, tom.age)      // Tom 38
}
```
## Указатели на структуры
Как и в случае с обычными переменнами, можно создавать указатели на структуры.

``` go
package main
import "fmt"

type person struct{
name string
age int
}

func main() {

    tom := person {name: "Tom", age: 22}
    var tomPointer *person = &tom
    tomPointer.age = 29
    fmt.Println(tom.age)        // 29
    (*tomPointer).age = 32
    fmt.Println(tom.age)        // 32
}
```
Для инициализации указателя на структуру необязательно присваивать ему адрес переменной. Можно присвоить адрес безымянного объекта следующим образом:

``` go
var tom *person = &person{name:"Tom", age:23}
var bob *person = new(person)
```
Для обращения к полям структуры через указатель можно использовать операцию разыменования ((*tomPointer).age), либо напрямую обращаться по указателю (tomPointer.age).

Также можно определять указатели на отдельные поля структуры:

``` go
tom := person {name: "Tom", age: 22}
var agePointer *int = &tom.age  // указатель на поле tom.age
*agePointer = 35            // изменяем значение поля
fmt.Println(tom.age)        //  35
```
# Обработка ошибок в Go
Обработка ошибок в языке программирования Go устроена немного иначе, чем в других языках. Здесь нет исключений в привычном понимании, вместо этого Go предлагает явный и предсказуемый подход через возвращаемые ошибки. Такой механизм делает код более надёжным, поскольку ошибки обрабатываются сразу после их возникновения, а не перехватываются на более поздних этапах выполнения программы. В этой статье мы разберём, как правильно работать с ошибками в Go, какие есть инструменты для их обработки и как писать надёжный код.

Как Go обрабатывает ошибки
В большинстве языков программирования ошибки обрабатываются через механизм исключений (exceptions). Это позволяет прервать выполнение кода и передать управление в блок catch (например, в Java, Python или C++). Однако в Go такой модели нет. Вместо этого ошибки передаются как обычные значения, что делает процесс обработки более явным и предсказуемым.

Go определяет интерфейс error, который используется для представления ошибок:
``` go
type error interface {
Error() string
}
```
Любой тип, реализующий метод Error(), можно считать ошибкой. Это даёт гибкость при создании собственных ошибок и позволяет передавать детальную информацию о возникшей проблеме.

Давайте рассмотрим базовый пример обработки ошибки:
``` go
package main

import (
"errors"
"fmt"
)

// Функция, выполняющая деление и возвращающая ошибку при некорректном вводе
func divide(a, b float64) (float64, error) {
if b == 0 {
return 0, errors.New("деление на ноль невозможно")
}
return a / b, nil
}

func main() {
result, err := divide(10, 0)
if err != nil {
fmt.Println("Ошибка:", err)
return
}
fmt.Println("Результат:", result)
}
```
Здесь функция divide возвращает два значения: результат вычисления и ошибку. Если передан ноль в качестве делителя, создаётся и возвращается ошибка. В main мы сразу проверяем её перед использованием результата. Такой стиль написания кода считается хорошей практикой в Go.

## Проверка и обработка ошибок
В Go широко распространена практика явной проверки ошибок после вызова функций. Это делает код более читаемым, контролируемым и предсказуемым. В отличие от исключений, где ошибка может "всплыть" и обработаться в другом месте, в Go обработка ошибок выполняется непосредственно там, где ошибка произошла.

Пример работы с файлами:
``` go
package main

import (
"fmt"
"os"
)

func main() {
file, err := os.Open("example.txt")
if err != nil {
fmt.Println("Ошибка при открытии файла:", err)
return
}
defer file.Close()

    fmt.Println("Файл успешно открыт")
}
```
Здесь, если файл не существует или его нельзя открыть, os.Open вернёт ошибку, которую мы сразу проверяем и обрабатываем. Такой подход предотвращает выполнение программы в некорректном состоянии.

## Создание собственных ошибок
Иногда встроенных ошибок недостаточно, и нам нужно создать свои собственные. Для этого в Go можно использовать два подхода:

### Создание ошибки с помощью errors.New или fmt.Errorf.
Определение пользовательского типа ошибки, реализующего интерфейс error.
Пример первого подхода:
``` go
package main

import (
"errors"
"fmt"
)

func checkValue(n int) error {
if n < 0 {
return errors.New("значение не может быть отрицательным")
}
return nil
}

func main() {
err := checkValue(-10)
if err != nil {
fmt.Println("Ошибка:", err)
} else {
fmt.Println("Всё в порядке")
}
}
```
Здесь функция checkValue возвращает ошибку, если передано отрицательное значение.

Теперь посмотрим на второй подход — создание собственного типа ошибки:
``` go
package main

import (
"fmt"
)

// Собственная ошибка с дополнительной информацией
type CustomError struct {
Code int
Msg  string
}

func (e *CustomError) Error() string {
return fmt.Sprintf("Ошибка %d: %s", e.Code, e.Msg)
}

func doSomething() error {
return &CustomError{Code: 404, Msg: "Ресурс не найден"}
}

func main() {
err := doSomething()
if err != nil {
fmt.Println("Произошла ошибка:", err)
}
}
```
Этот код демонстрирует, как можно передавать дополнительные сведения в ошибке, такие как код состояния. Это полезно при разработке серверных приложений и API.
## Defer
defer в Golang - это ключевое слово, которое используется для отложенного выполнения функции или метода до тех пор, пока текущая функция не завершится. Когда встречается оператор defer, Golang добавляет вызов функции или метода в стек отложенных вызовов, а затем продолжает выполнение текущей функции.

defer может быть использовано для управления ресурсами, таких как файлы или сетевые соединения, чтобы гарантировать, что они будут закрыты независимо от того, как завершится функция. Он также может быть использован для обработки ошибок, когда функция должна быть завершена раньше времени.

Вот пример, который показывает использование defer для закрытия файла:
``` go
package main

import (
"fmt"
"os"
)

func main() {
file, err := os.Open("example.txt")
if err != nil {
panic(err)
}

    // Закрыть файл после завершения функции
    defer file.Close()

    // ... Код для чтения файла ...
}
```
В этом примере мы открываем файл example.txt и затем используем defer для закрытия файла после того, как функция завершится. Если произойдет ошибка при открытии файла, программа вызовет функцию panic, которая приведет к немедленному завершению программы.
## Паника (panic) и восстановление (recover)
В Go, помимо стандартного механизма ошибок, есть возможность использования panic и recover. panic приводит к аварийному завершению программы, а recover позволяет обработать панику и продолжить выполнение. Однако этот механизм следует использовать только в исключительных ситуациях, таких как критические ошибки, из которых программа не может продолжать работу.

Пример использования panic и recover:
``` go
package main

import "fmt"

func mayPanic() {
defer func() {
if r := recover(); r != nil {
fmt.Println("Поймана паника:", r)
}
}()

    panic("непредвиденная ошибка!")
}

func main() {
mayPanic()
fmt.Println("Программа продолжает работу")
}
```
Здесь recover позволяет программе не завершаться аварийно, а перехватывает panic.