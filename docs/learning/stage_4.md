
# Переменные

## var

Переменная представляет именованный участок в памяти, который может хранить 
некоторое значение. Для определения переменной применяется ключевое слово `var`, 
после которого идет имя переменной, а затем указывается ее тип:

var имя_переменной тип_данных

``` go
var a, b, c string
```

## Краткое определение переменной `:=`

имя_переменной := значение

``` go
name := "Tom"
```

## Константы

Константы, как и переменные, хранят некоторые данные, но в отличие от переменных значения констант нельзя изменить, они устанавливаются один раз. Вычисление констант производится во время компиляции. Благодаря этому уменьшается количество работы, которую необходимо произвести во время выполнения, упрощается поиск ошибок, связанных с константами (так как некоторые из них можно обнаружить на момент компиляции).

Для определения констант применяется ключевое слово `const:`

``` go
const pi float64 = 3.1415
```

# Типы данных

## Целочисленные типы

### Ряд типов представляют целые числа:

- `int8`: представляет целое число от -128 до 127 и занимает в памяти 1 байт (8 бит)

- `int16`: представляет целое число от -32768 до 32767 и занимает в памяти 2 байта (16 бит)

- `int32`: представляет целое число от -2147483648 до 2147483647 и занимает 4 байта (32 бита)

- `int64`: представляет целое число от –9 223 372 036 854 775 808 до 9 223 372 036 854 775 807 и занимает 8 байт (64 бита)

- `uint8`: представляет целое число от 0 до 255 и занимает 1 байт

- `uint16`: представляет целое число от 0 до 65535 и занимает 2 байта

- `uint32`: представляет целое число от 0 до 4294967295 и занимает 4 байта

- `uint64`: представляет целое число от 0 до 18 446 744 073 709 551 615 и занимает 8 байт

- `byte`: синоним типа uint8, представляет целое число от 0 до 255 и занимает 1 байт

- `rune`: синоним типа int32, представляет целое число от -2147483648 до 2147483647 и занимает 4 байта

- `int`: представляет целое число со знаком, которое в зависимости о платформы может занимать либо 4 байта, либо 8 байт. То есть соответствовать либо int32, либо int64.

- `uint`: представляет целое беззнаковое число только без знака, которое, аналогично типу int, в зависимости о платформы может занимать либо 4 байта, либо 8 байт. То есть соответствовать либо uint32, либо uint64.

## Числа с плавающей точкой

### Для представления дробных чисел есть два типа:

- `float32`: представляет число с плавающей точкой от 1.4*10-45 до 3.4*1038(для положительных). Занимает в памяти 4 байта (32 бита)

- `float64`: представляет число с плавающей точкой от 4.9*10-324 до 1.8*10308 (для положительных) и занимает 8 байт.

Тип float32 обеспечивает шесть десятичных цифр точности, в то время как точность, обеспечиваемая типом float64, составляет около 15 цифр

## Комплексные числа

### Существуют отдельные типы для представления комплексных чисел:

`complex64`: комплексное число, где вещественная и мнимая части представляют числа float32

`complex128`: комплексное число, где вещественная и мнимая части представляют числа float64

Пример использования:

``` go
var f complex64 = 1+2i
var g complex128 = 4+3i
```
## Тип bool
Логический тип или тип bool может иметь одно из двух значений: true (истина) или false (ложь).

``` go
var isAlive bool = true
var isEnabled bool = false
```
## Строки
Строки представлены типом string. В Go строке соответствует строковый литерал - последовательность символов, заключенная в двойные кавычки:

``` go
var name string = "Том Сойер"
```
Кроме обычных символов строка может содержать специальные последовательности (управляющие последовательности), которые начинаются с обратного слеша \. Наиболее распространенные последовательности:

`\n`: переход на новую строку

`\r`: возврат каретки

`\t`: табуляция

`"`: двойная кавычка внутри строк

`\`: обратный слеш

## Значение по умолчанию

Если переменной не присвоено значение, то она имеет значение по умолчанию, которое определено для ее типа. Для числовых типов это число 0, для логического типа - false, для строк - ""(пустая строка).

## Неявная типизация

При определении переменной мы можем опускать тип в том случае, если мы явно инициализируем переменную каким-нибудь значением:

``` go
var name = "Tom"
```
В этом случае компилятор на основании значения неявно выводит тип переменной. Если присваивается строка, то то соответственно переменная будет представлять тип string, если присваивается целое число, то переменная представляет тип int и т.д.

То же самое по сути происходит при кратком определении переменной, когда также явным образом не указывается тип данных:

``` go
name := "Tom"
```
При этом стоит учитывать, что если мы не указываем у переменной тип, то ей обязательно надо присвоить некоторое начальное значение.

# Массивы
Массивы представляют последовательность элементов определенного типа. Массив определяется следующим способом:

1
var numbers [число_элементов]тип_элементов
Например, массив из пяти элементов типа int:

1
var numbers [5]int
При таком определении все элементы массива инициализируются значениями по умолчанию. Но также можно инициализировать элементы массива другими значениями:

1
var numbers [5]int = [5]int{1,2,3,4,5}
Значения передаются в фигурных скобках через запятую. При этом значений не может быть больше длины массива. В данном случае длина массива равна 5, поэтому нельзя в фигурных скобках определить больше пяти элементов. Но можно определить меньше элементов:

1
2
var numbers [5]int = [5]int{1,2}
fmt.Println(numbers)    // [1 2 0 0 0]
В этом случае элементы, для которых не указано значение, будут иметь значение по умолчанию.

Также можно применять сокращенное определение переменной массива:

``` go
numbers := [5]int{1,2,3,4,5}
```
Если в квадратных скобках вместо длины указано троеточие, то длина массива определяется, исходя из количества переданных ему элементов:

``` go
var numbers = [...]int{1,2,3,4,5}   // длина массива 5
numbers2 := [...]int{1,2,3}         // длина массива 3
fmt.Println(numbers)                // [1 2 3 4 5]
fmt.Println(numbers2)           // [1 2 3]
```
При этом длина массива является частью его типа. И, к примеру, следующие два массива представляют разные типы данных, хотя они и хранят данные одного типа:

``` go
var numbers [3]int = [3]int{1, 2, 3}
var numbers2 [4]int = [4]int{1, 2, 3, 4}
numbers = numbers2  // ! Ошибка
```
И в данном случае при присвоении мы получим ошибку, так как данные одного типа пытаемся передать переменной другого типа.

## Индексы

Для обращения к элементам массива применяются индексы - номера элементов. При этом нумерация начинается с нуля, то есть первый элемент будет иметь индекс 0. Индекс указывается в квадратных скобках. По индексу можно получить значение элемента, либо изменить его:

``` go
package main
import "fmt"

func main() {
var numbers [5]int = [5]int{1,2,3,4,5}
fmt.Println(numbers[0])     // 1
fmt.Println(numbers[4])     // 5
numbers[0] = 87
fmt.Println(numbers[0])     // 87
}
```
Индексы в массиве фактически выступают в качестве ключей, по которым можно обратиться к соответствующему значению. И в прицнипе мы можем явным образом указать, какому ключу какое значение будет соответствовать. При этому числовые ключи необязательно располагать в порядке возрастания:

``` go
colors := [3]string{2: "blue", 0: "red", 1: "green"}
fmt.Println(colors[2])      // blue
```

# Условные конструкции
Условные конструкции проверяют истинность некоторого условия и в зависимости от результатов проверки позволяют направить ход программы по одному из путей.

## if...else
Конструкция `if` принимает условие - выражение, которое возвращает значение типа `bool`. И если это условие истинно, то выполняется последующий блок инструкций.

``` go
package main
import "fmt"

func main() {

    a := 6
    b := 7
    if a < b {
        fmt.Println("a is less than b")
    }
}
```
Условие ставится после оператора `if`. В данном случае проверяется, меньше ли значение переменной `a` чем значние переменой `b`. Поскольку в данном случае значение переменной `a` действительно меньше значения переменной `b`, то есть условие возвращает `true`, то будет выполнять последующий блок кода, который выводит на консоль сообщение.

Если необходимо задать альтернативную логику, которая выполняется, в случае если условие неверно, то добавляется выражение `else`:

``` go
package main
import "fmt"

func main() {

    a := 6
    b := 7
    if a < b {
        fmt.Println("a меньше b")
    }else{
        fmt.Println("a больше b")
    }
}
```
Таким образом, если условное выражение после оператора `if` истинно, то выполняется блок после `if`, если ложно - выполняется блок после `else`.

Если необходимо проверить несколько альтернативных вариантов, то можно добавить выражения `else if`:

``` go
package main
import "fmt"

func main() {

    a := 8
    b := 8
    if a < b {
        fmt.Println("a меньше b")
    }else if a > b{
        fmt.Println("a больше b")
    } else{
        fmt.Println("a равно b")
    }
}
```
Таким образом, если выражение после `if` истинно, то срабатывает блок `if`. Иначе проверяется выражение после `else if`. Если оно истинно, то выполняется блок `else if`. Если оно ложно, то выполняется блок `else`.

Выражений else if может быть множество:

``` go
if a ==9 {
fmt.Println("a = 9")
}else if a == 8{
fmt.Println("a = 8")
} else if a == 7{
fmt.Println("a == 7")
}
```
## Switch
Конструкция `switch` проверяет значение некоторого выражения. С помощью операторов `case` определяются значения для сравнения. Если значение после оператора `case` совпадает со значением выражения из `switch`, то выполняется код данного блока `case`.

``` go
package main
import "fmt"

func main() {

    a := 8
    switch(a) {
        case 9: 
            fmt.Println("a = 9")
        case 8: 
            fmt.Println("a = 8")
        case 7: 
            fmt.Println("a = 7")
    }
}
```
В качестве выражения конструкция `switch` использует переменную `a`. Ее значение последовательно сравнивается со значениями после операторов case. Поскольку переменная `a` равна 8, то будет выполняться блок `case 8: fmt.Println("a = 8")`. Остальные блоки `case` не выполняются.

При этом после оператора `switch` мы можем указывать любое выражение, которое возвращает значение. Например, операцию сложения:

``` go
a := 7
switch(a + 2) {
case 9:
fmt.Println("9")
case 8:
fmt.Println("8")
case 7:
fmt.Println("7")
}
```
Также конструкция `switch` может содержать необязательных блок `default`, который выполняется, если ни один из операторов `case` не содержит нужного значения:

``` go
package main
import "fmt"

func main() {

    a := 87
    switch(a) {
        case 9: 
            fmt.Println("a = 9")
        case 8: 
            fmt.Println("a = 8")
        case 7: 
            fmt.Println("a = 7")
        default: 
            fmt.Println("значение переменной a не определено")
    }
}
```
Также можно указывать после оператора `case` сразу несколько значений:

``` go
a := 5
switch(a) {
case 9: fmt.Println("a = 9")
case 8: fmt.Println("a = 8")
case 7: fmt.Println("a = 7")
case 6, 5, 4:
fmt.Println("a = 6 или 5 или 4, но это не точно")
default:
fmt.Println("значение переменной a не определено")
}
```
# Циклы

Циклы позволяют в зависимости от определенного условия выполнять некоторые действия множество раз. Фактически в Go есть только один цикл - цикл for, который может принимать разные формы. Этот цикл имеет следующее формальное определение:


`for [инициализация счетчика]; [условие]; [изменение счетчика]{
// действия
}`
Например, выведем с помощью цикла квадраты чисел:

``` go
package main
import "fmt"

func main() {

    for i := 1; i < 10; i++{
        fmt.Println(i * i)
    }
}
```
## Вложенные циклы
Циклы могут быть вложенными, то есть располагаться внутри других циклов. Например, выведем на консоль таблицу умножения:


package main
import "fmt"

func main() {

    for i := 1; i < 10; i++{
        for j := 1; j < 10; j++{
            fmt.Print(i * j, "\t")
        }
        fmt.Println()
    }
}
## Перебор массивов
Для перебора массивов можно использовать следующую форму цикла for:

``` go
for индекс, значение := range массив{
// действия
}
```
При переборе мы можем по отдельности получить индекс элемента в массиве и значение этого элемента. Например, перебирем массив строк:

``` go
var users = [3]string{"Tom", "Alice", "Kate"}
for index, value := range users{
fmt.Println(index, value)
}
```
Если мы не планируем использовать значения или индексы элементов, то мы можем вместо них указать прочерк. Например, нам не нужны индексы:
``` go
for _, value := range users{
fmt.Println(value)
}
```
Но также для перебора массива можно использовать и стандартную версию цикла for:

``` go
var users = [3]string{"Tom", "Alice", "Kate"}
for i:= 0; i < len(users); i++{
fmt.Println(users[i])
}
```
В данном случае счетчик i играет роль индекса. Цикл выполняется, пока счетчик i не станет равным длине массива, которую можно получить с помощью функции len()
## Операторы break и continue
Может возникнуть ситуация, когда нам надо при определенных условиях завершить текущую итерацию цикла, не выполнять все инструкции цикла, а сразу перейти к следующей итерации. В этом случае можно использовать оператор continue. Например, в массиве могу быть, как положительные, так и отрицательные числа. Допустим, нам нужна сумма только положительных чисел, поэтому, если нам встретится отрицательное число, мы можем просто перейти к следующей итерации с помощью continue:

``` go
var numbers = [10]int{1, -2, 3, -4, 5, -6, -7, 8, -9, 10}
var sum = 0

for _, value := range numbers{
if value < 0{
continue        // переходим к следующей итерации
}
sum += value
}
fmt.Println("Sum:", sum)    // Sum: 27
```
Оператор break полностью осуществляет выход из цикла:

``` go
var numbers = [10]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
var sum = 0

for _, value := range numbers{
if value > 4{
break       // если число больше 4 выходим из цикла
}
sum += value
}
fmt.Println("Sum:", sum)    // Sum: 10
```
# Функции и их параметры
## Функции

Функция представляет блок операторов, которые все вместе выполняют какую-то определенную задачу. С помощью функций можно многократно вызывать ее блок операторов как единое целое в других частях программы.

Функция объявляется следующим образом:

``` go
func имя_функции (список_параметров) (типы_возвращаемых_значений){
выполняемые_операторы
}
```
Функция определяется с помощью ключевого слова func, после которого идет имя функции. Затем в скобках идет список параметров. После списка параметров определяются типы возвращаемых из функции значений (если функция возвращает значения). И далее в фигурных скобках идут собственно те операторы, из которых состоит функция.

Название функции вместе с типами ее параметров и типами возвращаемых значений еще называют сигнатурой.

По умолчанию каждая программа на языке Go должна содержать как минимум одну функцию - функцию `main`, которая является входной точкой в приложение:

``` go
package main
import "fmt"

func main() {
fmt.Println("Hello Go")
}
```
Функция `main` начинается с ключевого слова `func`, затем идет название - `main`. Функция не принимает никаких параметров, поэтому после названия идут пустые скобки. Функция main не возвращает никакого результата, поэтому после пустых скобок не указывается тип возвращаемого значения. И тело функции в фигурных скобках фактически состоит из вызова другой функции - `fmt.Println()`, которая выводит строку на консоль.

Теперь определим еще одну функцию:

``` go
package main
import "fmt"

func main() {

}

func hello(){
fmt.Println("Hello World")
}
```
В данном случае мы определили функцию `hello`, которая не принимает никаких параметров, ничего не возвращает и просто выводит на консоль строку. Определить функцию можно в том же файле, где расположена функция `main`. Но если мы запустим эту программу, но на консоли мы ничего не увидим. Потому что программа выполняет только те действия, которые определены внутри функции `main`. Имя она является входной точкой в приложение. И если мы хотим выполнить в программе нашу функцию `hello`, то нам надо вызвать ее в функции `main`:

``` go
package main
import "fmt"

func main() {
hello()
hello()
hello()
}

func hello(){
fmt.Println("Hello World")
}
```
Для вызова функции пишется ее имя, после которого в скобках указываются значения для параметров функции. Но поскольку в данном случае функция hello не имеет параметров, то после ее названия пишем просто пустые скобки. И таким образом, при выполнении программы на консоль три раза будет выведена строка "Hello World":

## Параметры функции
Через параметры функция получает входные данные. Параметры указываются в скобках после имени функции. Для каждого параметра указывается имя и тип (как для переменной). Друг от друга параметров разделяются запятыми. При вызове функции необходимо передать значения для всех ее параметров. Например, мы хотим использовать функцию, которая складывает два любых числа:

``` go
package main
import "fmt"

func main() {
add(4, 5)   // x + y = 9
add(20, 6)  // x + y = 26
}

func add(x int, y int){
var z = x + y
fmt.Println("x + y = ", z)
}
```
Функция add имеет два параметра: x и y. Оба параметра представляют тип int, то есть целые числа. В самой функции определяется переменная, которая хранит сумму этих чисел. И затем сумма чисел выводится на консоль.

В функции main вызывается функция add. Так как функция принимает два параметра, то при вызове ей необходимо передать значения для этих параметров или два аргумента. Причем эти значения должны соответствовать параметрам по типу. То есть если параметр представляет тип int, то ему необходимо передать число.

Значения передаются по позиции. То есть первое значение получит первый параметр, второе значение - входной параметр и так далее. В итоге мы получим следующий консольный вывод:

``` go
x + y = 9
x + y = 26
```
Если несколько параметров подряд имеют один и тот же тип, то мы можем указать тип только для последнего параметра, а предыдущие параметры также будут представлять этот тип:

``` go
package main
import "fmt"

func main() {
add(1, 2, 3.4, 5.6, 1.2)
}
func add(x, y int, a, b, c float32){
var z = x + y
var d = a + b + c
fmt.Println("x + y = ", z)
fmt.Println("a + b + c = ", d)
}
```
В качестве аргументов при вызове функции можно передавать и значения переменных, результаты операций или других функций, но при этом следует учитывать, что аргументы в функцию всегда передаются по значению:

``` go
package main
import "fmt"

func main() {
var a = 8
fmt.Println("a before: ", a)
increment(a)
fmt.Println("a after: ", a)
}
func increment(x int){

    fmt.Println("x before: ", x)
    x = x + 20
    fmt.Println("x after: ", x)
}
```
## Неопределенное количество параметров
В Go функция может принимать неопределенное количество параметров одного типа. Например, нам надо получить сумму чисел, но мы точно не значем, сколько чисел будут переданы в функцию:

``` go
package main
import "fmt"

func main() {
add(1, 2, 3)        // sum = 6
add(1, 2, 3, 4)     // sum = 10
add(5, 6, 7, 2, 3)  // sum = 23
}

func add(numbers ...int){
var sum = 0
for _, number := range numbers{
sum += number
}
fmt.Println("sum = ", sum)
}
```
Для определения параметра, который представляет неопределенное количество значений, перед типом этих значений ставится многоточие: numbers ...int. То есть через подобный параметр мы получаем несколько значений типа int.

При вызове мы можем передать в функцию add разное количество чисел:

``` go
add(1, 2, 3)        // sum = 6
add(1, 2, 3, 4)     // sum = 10
add(5, 6, 7, 2, 3)  // sum = 23
```
От этого случае следует отличать передачу среза в качестве параметра:

``` go
add([]int{1, 2, 3})
add([]int{1, 2, 3, 4})
add([]int{5, 6, 7, 2, 3})
```
В данном случае мы получим ошибку, так как передача среза не эквивалентна передаче неопределенного количества параметров того же типа. Если мы хотим передать срез, то надо указать после аргумента-массива многоточие:

``` go
add([]int{1, 2, 3}...)

add([]int{1, 2, 3, 4}...)

var nums = []int{5, 6, 7, 2, 3}
add(nums...)
```
# Срезы
Срезы (slice) представляют последовательность элементов одного типа переменной длины. В отличие от массивов длина в срезах не иксирована и динамически может меняться, то есть можно добавлять новые элементы или удалять уже существующие.

Срез определяется также, как и массив, за тем исключением, что у него не указывается длина:

``` go
var users []string
```
Также срез можно инициализировать значениями:

``` go
var users = []string{"Tom", "Alice", "Kate"}
```
// или так
``` go
users2 := []string{"Tom", "Alice", "Kate"}
```
К элементам среза обращение происходит также, как и к элементам массива - по индексу и также мы можем перебирать все элементы с помощью цикла `for`:

``` go
var users []string = []string{"Tom", "Alice", "Kate"}
fmt.Println(users[2])   // Kate
users[2] = "Katherine"

for _, value := range users{
fmt.Println(value)
```
С помощью функции `make()` можно создать срез из нескольких элементов, которые будут иметь значения по умолчанию:

``` go
var users []string = make([]string, 3)
users[0] = "Tom"
users[1] = "Alice"
users[2] = "Bob"
```
## Добавление в срез
Для добавления в срез применяется встроенная функция append(slice, value). Первый параметр функции - срез, в который надо добавить, а второй параметр - значение, которое нужно добавить. Результатом функции является увеличенный срез.

``` go
users := []string{"Tom", "Alice", "Kate"}
users = append(users, "Bob")

for _, value := range users{
fmt.Println(value)
}
```
## Оператор среза
Оператор среза `s[i:j]` создает из последовательности s новый срез, который содержит элементы последовательности `s` с `i` по `j-1`. При этом должно соблюдаться условие `0 <= i <= j <= cap(s)`. В качестве исходной последовательности, из которой берутся элементы, может использоваться массив, указатель на массив или другой срез. В итоге в полученном срезе будет `j-i` элементов.

Если значение `i` не указано, то применяется по умолчанию значение 0. Если значение `j` не указано, то вместо него используется длина исходной последовательности `s`.

``` go
// исходный массив
initialUsers := [8]string{"Bob", "Alice", "Kate", "Sam", "Tom", "Paul", "Mike", "Robert"}
users1 := initialUsers[2:6]     // с 3-го по 6-й
users2 := initialUsers[:4]      // с 1-го по 4-й
users3 := initialUsers[3:]      // с 4-го до конца

fmt.Println(users1)     // ["Kate", "Sam", "Tom", "Paul"]
fmt.Println(users2)     // ["Bob", "Alice", "Kate", "Sam"]
fmt.Println(users3)     // ["Sam", "Tom", "Paul", "Mike", "Robert"]
```
## Удаление элемента
Что делать, если необходимо удалить какой-то определенный элемент? В этом случае мы можем комбинировать функцию append и оператор среза:

``` go
users := []string{"Bob", "Alice", "Kate", "Sam", "Tom", "Paul", "Mike", "Robert"}
//удаляем 4-й элемент
var n = 3
users = append(users[:n], users[n+1:]...)   
fmt.Println(users)      //["Bob", "Alice", "Kate", "Tom", "Paul", "Mike", "Robert"]
```