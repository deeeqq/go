
# Переменные

## var

Переменная представляет именованный участок в памяти, который может хранить 
некоторое значение. Для определения переменной применяется ключевое слово `var`, 
после которого идет имя переменной, а затем указывается ее тип:

var имя_переменной тип_данных

```go
var a, b, c string
```

## Краткое определение переменной `:=`

имя_переменной := значение

```go
name := "Tom"
```

## Константы

Константы, как и переменные, хранят некоторые данные, но в отличие от переменных значения констант нельзя изменить, они устанавливаются один раз. Вычисление констант производится во время компиляции. Благодаря этому уменьшается количество работы, которую необходимо произвести во время выполнения, упрощается поиск ошибок, связанных с константами (так как некоторые из них можно обнаружить на момент компиляции).

Для определения констант применяется ключевое слово `const:`

```go
const pi float64 = 3.1415
```

# Типы данных

## Целочисленные типы

### Ряд типов представляют целые числа:

- `int8`: представляет целое число от -128 до 127 и занимает в памяти 1 байт (8 бит)

- `int16`: представляет целое число от -32768 до 32767 и занимает в памяти 2 байта (16 бит)

- `int32`: представляет целое число от -2147483648 до 2147483647 и занимает 4 байта (32 бита)

- `int64`: представляет целое число от –9 223 372 036 854 775 808 до 9 223 372 036 854 775 807 и занимает 8 байт (64 бита)

- `uint8`: представляет целое число от 0 до 255 и занимает 1 байт

- `uint16`: представляет целое число от 0 до 65535 и занимает 2 байта

- `uint32`: представляет целое число от 0 до 4294967295 и занимает 4 байта

- `uint64`: представляет целое число от 0 до 18 446 744 073 709 551 615 и занимает 8 байт

- `byte`: синоним типа uint8, представляет целое число от 0 до 255 и занимает 1 байт

- `rune`: синоним типа int32, представляет целое число от -2147483648 до 2147483647 и занимает 4 байта

- `int`: представляет целое число со знаком, которое в зависимости о платформы может занимать либо 4 байта, либо 8 байт. То есть соответствовать либо int32, либо int64.

- `uint`: представляет целое беззнаковое число только без знака, которое, аналогично типу int, в зависимости о платформы может занимать либо 4 байта, либо 8 байт. То есть соответствовать либо uint32, либо uint64.

## Числа с плавающей точкой

### Для представления дробных чисел есть два типа:

- `float32`: представляет число с плавающей точкой от 1.4*10-45 до 3.4*1038(для положительных). Занимает в памяти 4 байта (32 бита)

- `float64`: представляет число с плавающей точкой от 4.9*10-324 до 1.8*10308 (для положительных) и занимает 8 байт.

Тип float32 обеспечивает шесть десятичных цифр точности, в то время как точность, обеспечиваемая типом float64, составляет около 15 цифр

## Комплексные числа

### Существуют отдельные типы для представления комплексных чисел:

`complex64`: комплексное число, где вещественная и мнимая части представляют числа float32

`complex128`: комплексное число, где вещественная и мнимая части представляют числа float64

Пример использования:

```go
var f complex64 = 1+2i
var g complex128 = 4+3i
```
## Тип bool
Логический тип или тип bool может иметь одно из двух значений: true (истина) или false (ложь).

```go
var isAlive bool = true
var isEnabled bool = false
```
## Строки
Строки представлены типом string. В Go строке соответствует строковый литерал - последовательность символов, заключенная в двойные кавычки:

```go
var name string = "Том Сойер"
```
Кроме обычных символов строка может содержать специальные последовательности (управляющие последовательности), которые начинаются с обратного слеша \. Наиболее распространенные последовательности:

`\n`: переход на новую строку

`\r`: возврат каретки

`\t`: табуляция

`"`: двойная кавычка внутри строк

`\`: обратный слеш

## Значение по умолчанию

Если переменной не присвоено значение, то она имеет значение по умолчанию, которое определено для ее типа. Для числовых типов это число 0, для логического типа - false, для строк - ""(пустая строка).

## Неявная типизация

При определении переменной мы можем опускать тип в том случае, если мы явно инициализируем переменную каким-нибудь значением:

```go
var name = "Tom"
```
В этом случае компилятор на основании значения неявно выводит тип переменной. Если присваивается строка, то то соответственно переменная будет представлять тип string, если присваивается целое число, то переменная представляет тип int и т.д.

То же самое по сути происходит при кратком определении переменной, когда также явным образом не указывается тип данных:

```go
name := "Tom"
```
При этом стоит учитывать, что если мы не указываем у переменной тип, то ей обязательно надо присвоить некоторое начальное значение.

# Массивы
Массивы представляют последовательность элементов определенного типа. Массив определяется следующим способом:

1
var numbers [число_элементов]тип_элементов
Например, массив из пяти элементов типа int:

1
var numbers [5]int
При таком определении все элементы массива инициализируются значениями по умолчанию. Но также можно инициализировать элементы массива другими значениями:

1
var numbers [5]int = [5]int{1,2,3,4,5}
Значения передаются в фигурных скобках через запятую. При этом значений не может быть больше длины массива. В данном случае длина массива равна 5, поэтому нельзя в фигурных скобках определить больше пяти элементов. Но можно определить меньше элементов:

1
2
var numbers [5]int = [5]int{1,2}
fmt.Println(numbers)    // [1 2 0 0 0]
В этом случае элементы, для которых не указано значение, будут иметь значение по умолчанию.

Также можно применять сокращенное определение переменной массива:

``` go
numbers := [5]int{1,2,3,4,5}
```
Если в квадратных скобках вместо длины указано троеточие, то длина массива определяется, исходя из количества переданных ему элементов:

```go
var numbers = [...]int{1,2,3,4,5}   // длина массива 5
numbers2 := [...]int{1,2,3}         // длина массива 3
fmt.Println(numbers)                // [1 2 3 4 5]
fmt.Println(numbers2)           // [1 2 3]
```
При этом длина массива является частью его типа. И, к примеру, следующие два массива представляют разные типы данных, хотя они и хранят данные одного типа:

``` go
var numbers [3]int = [3]int{1, 2, 3}
var numbers2 [4]int = [4]int{1, 2, 3, 4}
numbers = numbers2  // ! Ошибка
```
И в данном случае при присвоении мы получим ошибку, так как данные одного типа пытаемся передать переменной другого типа.

## Индексы

Для обращения к элементам массива применяются индексы - номера элементов. При этом нумерация начинается с нуля, то есть первый элемент будет иметь индекс 0. Индекс указывается в квадратных скобках. По индексу можно получить значение элемента, либо изменить его:

``` go
package main
import "fmt"

func main() {
var numbers [5]int = [5]int{1,2,3,4,5}
fmt.Println(numbers[0])     // 1
fmt.Println(numbers[4])     // 5
numbers[0] = 87
fmt.Println(numbers[0])     // 87
}
```
Индексы в массиве фактически выступают в качестве ключей, по которым можно обратиться к соответствующему значению. И в прицнипе мы можем явным образом указать, какому ключу какое значение будет соответствовать. При этому числовые ключи необязательно располагать в порядке возрастания:

``` go
colors := [3]string{2: "blue", 0: "red", 1: "green"}
fmt.Println(colors[2])      // blue
```